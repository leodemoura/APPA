\documentclass{llncs}

\usepackage{url,amsmath,amssymb}
\usepackage{color}

% Dissemination Plans and Important Dates:

% - Your tutorial shall be acompanied by a paper, 
% which will be published as a chapter of a book 
% in the "Logic and Foundations of Mathematics" series 
% by College Publications. 

% - Please send us a good, though not necessarily final, 
% version of your paper ** BEFORE 1st OF JUNE **. 
% This will give us (and College Publications) sufficient time 
% to produce printed copies of a preliminary version of the book, 
% to be distributed to registered participants.

% - Afterwards there will be plenty of time to improve
% the paper/chapter and incorporate feedback gained during the event. 


% General remarks:

% - The target audience (for both the tutorials and 
% the accompanying papers) consists of Ph.D. students, 
% young post-docs and researchers from other logic-related communities.

% - Avoid obscurity and clarify concepts that might be 
% unknown to people from other communities.

% - Strive for a self-contained paper, but be concise and 
% cite papers where readers may find more information.

% - Do not hesitate to build bridges between your domain and 
% other proof-related communities if you have some ideas to do so. 
% These bridges should lead to interesting discussions during the workshop.

% - You are encouraged to compare what is done in your community 
% with what is done in other communities. 
% Try to understand and explain why your community does things differently.
% This could lead to interesting discussions too.

% - This template aims at ensuring a 
% reasonably uniform style for all speakers. 
% Nevertheless, feel free to deviate from the template if you need. 
% We are aware that not all questions are applicable to all speakers.


% We hope the questions here will guide you 
% in the production of your tutorial.

% If anything is unclear, if you have any questions, contact us!

% Thank you!

\newcommand{\Note}[1]{\textcolor{blue}{[#1]}}

\title{ Proofs in Satisfiability Modulo Theories } 
% Please select a general title that reflects 
% the community you are going to represent in the event.

\author{
  Clark Barrett \inst{1}
  \and 
  Leonardo de Moura \inst{2}
  \and
  Pascal Fontaine \inst{3}
}

\authorrunning{C.\~Barrett \and L.\~de Moura \and P.\~Fontaine}

\institute{
  New York University\\
  \email{barrett@cs.nyu.edu}
  \and 
  Microsoft Research \\
  \email{leonardo@microsoft.com}
  \and
  University of Lorraine and INRIA\\
  \email{pascal.fontaine@inria.fr}
}

\begin{document}

\maketitle

\section{Introduction}

Satisfiability Modulo Theories (SMT) solvers\footnote{We refer
  to~\cite{Barrett14} for a survey on SMT.} check the satisfiability of (mostly
first-order) formulas written in a language containing interpreted predicates
and functions.  These interpreted symbols are defined by a first-order theory
(e.g.\ equality, array operators {\tt read} and {\tt write},\dots) or by a
structure (e.g.\ the integer numbers equipped with constants, addition,
equality, and inequalities).  Theories usually implemented within SMT solvers
include the empty theory (a.k.a.\ the theory of uninterpreted symbols with
equality), linear arithmetic on integers and/or reals, non-linear arithmetic on
reals, bit-vectors and the theory of arrays.  A very small example of input
formula for an SMT solver is
\begin{displaymath}
a \leq b \wedge b \leq a + x \wedge x = 0 \wedge
 \big[ f(a) \neq f(b) \vee (q(a) \wedge \neg q(b + x)) \big].
\end{displaymath}
The above formula uses equality, linear arithmetic and uninterpreted symbols
($q$ and $f$), within some Boolean combination.  The input language of SMT
solvers is standardized in the SMT-LIB format, currently in its version
2.0~\cite{Barrett15}.  Figure~\ref{fig:smtlib} gives a translation of our example formula
in this format.  The format currently does not provide any guideline for proof
output.

\begin{figure}
{\footnotesize
\begin{verbatim}
(set-logic QF_UFLRA)
(set-info :source | Example formula in SMT-LIB 2.0 |)
(set-info :smt-lib-version 2.0)
(declare-fun f (Real) Real)
(declare-fun q (Real) Bool)
(declare-fun a () Real)
(declare-fun b () Real)
(declare-fun x () Real)
(assert (and (<= a b) (<= b (+ a x)) (= x 0)
             (or (not (= (f a) (f b))) (and (q a) (not (q (+ b x)))))))
(check-sat)
(exit)
\end{verbatim}
}
\caption{\label{fig:smtlib} An formula, written in SMT-LIB 2.0}
\end{figure}

Whereas SMT solvers were designed originally as decision procedures for
decidable quantifier-free fragments, some SMT solvers nowadays tackle
quantifiers, are decision procedures for some decidable quantified fragments
(see e.g.~\cite{Ge1,Ge2}), and refutational completeness for first-order logic
(with equality but without further interpreted symbols) is an explicit goal.
Also, some SMT solvers now deal with theories that are undecidable even in the
quantifier-free case, for instance non-linear arithmetic on integers~\cite{Borralleras1}.

In some aspects, and also in their implementation, SMT solvers can be seen as
extensions of propositional satisfiability (SAT) solvers to more expressive
languages.  They lift the efficiency of SAT solvers to richer logics:
state-of-the-art SMT solvers are able to deal with very large formulas,
containing thousands of atoms.  Very schematically, an SMT solver abstracts its
input to propositional logic by replacing every atom with a fresh proposition,
e.g., for the above example,
\begin{displaymath}
p_{a \leq b} \wedge p_{b \leq a + x} \wedge p_{x = 0} \wedge
 \big[ \neg p_{f(a) = f(b)} \vee (p_{q(a)} \wedge \neg p_{q(b + x)}) \big].
\end{displaymath}
The underlying SAT solver is used to provide Boolean models for this
abstraction, e.g.\
\begin{displaymath}
\{ p_{a \leq b}, p_{b \leq a + x}, p_{x = 0}, \neg p_{f(a) = f(b)} \}
\end{displaymath}
and the theory reasoner repeatedly refutes these models and refines the Boolean
abstraction by adding new clauses (in this case $\neg p_{a \leq b} \vee \neg
p_{b \leq a + x} \vee \neg p_{x = 0} \vee p_{f(a) = f(b)}$) until either the
theory reasoner agrees with the model found by the SAT solver, or the
propositional abstraction is refined to an unsatisfiable formula.  As a
consequence, propositional reasoning and theory reasoning are quite well
distinguished.  Naturally, the interaction between the theory reasoner and the
SAT reasoning is in practice much more subtle than the above naive description,
but even when advanced techniques (e.g.\ eager decision procedures\marginpar{I
  am always confused about the best term to use here, online, eager\dots Please
  correct me} and theory propagation, see again~\cite{Barrett14}) are used,
propositional and theory reasoning are not very strongly mixed.  SMT proofs will
also feature an interleaving of SAT proofs and theory reasoning proofs.

% PF this should be improved
The theory reasoner may be a decision procedure for one theory, e.g.\ congruence
closure~\cite{Nelson2,Nieuwenhuis6} for uninterpreted symbols or a simplex-based
procedure~\cite{Dutertre1} for linear arithmetics, but it is most of the time a
combination of decision procedures.  Combination
frameworks~\cite{Nelson3,Tinelli1} build decision procedures for sets of
literals mixing interpreted symbols from several decidable languages (like the
aforementioned linear arithmetic and uninterpreted symbols) into one decision
procedure for the union of languages.  Combining decision procedures is possible
if the theories in the combination fulfil some properties.  For instance,
theories used in SMT solvers are often \emph{stably-infinite}\footnote{A theory
  is stably-infinite if every satisfiable set of literals in the theory has an
  infinite model.} and disjoint; this is notably the case for linear arithmetic
on integers and reals, and for uninterpreted symbols.  Combining theories often
either involve guessing which shared terms are equal and which are not, or,
equivalently, communicating disjunctions of equalities between decision
procedures.  Again, proofs for a combination of theories will be built from
proofs related to the theories in the combinations; the component proofs will
simply be combined using Boolean reasoning rules.

Quantifier reasoning in SMT is still mostly done through
instantiation~\cite{Moura9}.  Proofs involving quantifier reasoning are thus
just ground proofs augmented with some instantiation steps.  Skolemization is
however not trivial.  Giving a detailed proof of clausification and rewriting of
the ground instances is also not an easy task.



\Note{Pascal}
% Briefly introduce your kind of proof production tool 
% (e.g. Sat-solvers, SMT-solvers, First-order ATPs, 
% Higher-order ATPs, Proof Assistants, ...).
% Try to give an overview encompasing all your community. 
% If possible, do not to restrict yourself only to the tool(s) you develop.
Overview of proofs in SMT.  Proofs are basically resolution plus theory
lemmas.  Mention that one challenge is to keep enough information to produce
proofs without being too slow.

\Note{Clark}
% What are the tools that pioneered proof production in your area? 
% What are the tools that currently produce proofs? 
% How widespread is the feature of proof production 
% among tools in your area? 
% How was the historical evolution of the 
% proof production feature in your area? 
% If the tools in your area cannot produce proofs easily, explain why, 
% and describe the current trends to alleviate this problem.
History of proofs in SMT.  CVC tools, Z3, veriT
MathSAT has support for proofs, but unclear what the format is (brief mention
in MathSAT5 paper)
Mention Fx7 - ``Rocket fast proof checking'' paper

% Is there an open-source and minimalistic 
% *proof-producing* version of your kind of tool that would be
% particularly suitable for beginners to look at and modify?
I fear CVC4 is too large to be good for beginners - how about veriT?

PF: veriT is much smaller than CVC4, but not cleaner.  One can say:

Unlike SAT solver, SMT solvers are usually quite large pieces of software:
besides the propositional reasoning, they include decision procedures that can
themselves be quite complex.  Furthermore, the components (i.e.\ the various
decision procedures and the propositional reasoner) can be intricately mixed
together.  Implementing a new SMT solver from scratch, or even getting into the
code of an existing SMT solver, is a tedious task.  The OpenSMT solver is maybe
the one that includes the best in its philosophy a less stiff learning curve for
new developers.

\section{Proof Systems and Proof Consumption}

\Note{Pascal}
What are the common proof techniques across SMT?  Mention resolution,
equality/congruence reasoning.  Otherwise, theory-specific reasoning varies a lot.

% Please list the (most common) proof systems 
% (e.g. resolution, superposition, tableaux, 
% sequent calculus, natural deduction, ...) 
% underlying state-of-the-art tools of your kind.

% Please show the inference rules of 
% (some of) these proof systems explicitly. 
% Use, for example, proof.sty or bussproofs.sty.

% Why are these proof systems particularly useful for 
% your automated deduction tools? 
% Which features make them suitable? 
% What is not so convenient in them?

% What are the trends w.r.t. proof systems for your kind of tool?

%\section{Proof Consumption}
Discuss how SMT solvers depend on reolution proofs from SAT.

% Does your kind of tool consume proofs from another kind of tool? 
% (e.g. SMT-solvers using (proofs from) sat-solvers; 
% higher-order ATPs and proof assistants using (proofs from) 
% first-order ATPs; ...)

% If so, is there anything that could be improved in the proofs 
% that are generated by this other kind of tool?

% If your tool consumes proofs from other tools, 
% is it only a proof-checker or is
% it a wider tool also used to build proofs by its own? 
% If it is a wider tool, do you also provide a lighter version of 
% your tool that is dedicated to proof-checking? 
% If not, would it be desirable?

% What are the trends?


\section{Proof Search}

\Note{Clark}
How do the proof search techniques in SMT affect proof production?  For
example, rewriting, CNF conversion, preprocessing are challenging for proofs.
Some processing is typically disabled when producing proofs.

% Which algorithms are used to search for a proof/refutation? 
% Is the procedure able to find (counter-)models as well?

% Which criteria (e.g. speed, sizes (or other measures) of proofs/models)
% are used to evaluate whether a procedure is better than another?

% What are the "bottlenecks" that prevent current procedures 
% from solving more problems?

% Is there any mismatch between the abstract proof systems and 
% the implemented proof search procedures? 
% If so, how big is the gap between proof theory 
% and automated deduction in your field? 
% Would it be possible/desirable to develop proof systems 
% that are closer to the actual implementations?

% Are there any particular decision procedures or 
% proof search procedures that are not well-covered by proof theory yet?

% Do the proof search procedures guarantee that an optimal proof 
% (for some sense of "optimal") will be found, if a proof exists?

% Are there proof search optimization techniques 
% (e.g. resolution refinements, subsumption, 
% in-processing) that succesfully improve theorem proving efficiency, 
% but may be harmful for the generation of "good" (e.g. short, detailed, easy to check, ...) proofs? 
% Which techniques are harmful? Which are harmless?

% If the generated proofs are not optimal, 
% what kinds of redundancies may they contain? 
% Are there methods to improve the proofs in a post-processing phase? 
% Would it be possible/profitable to modify the existing 
% proof search procedures so that they generate better proofs, 
% that do not need to be post-processed afterwards?

% If the generated proofs are optimal but depend on the 
% kind of proof-checker that is used to verify the produced proofs, 
% explicit the dependency you rely on to generate optimal proofs.

% What are the trends w.r.t. proof search methods for your kind of tool?

\section{Introduction to Proof Implementations for SMT}

\Note{Clark}
There is no standard format for SMT.  There has been some discussion and even
some proposals.  Mention various proposals.  Below, we will discuss four
implementations of proofs in SMT.  The approaches are different enough to
warrant separate treatment.

\section{The CVC Family of SMT Solvers}
\Note{Clark}
\subsection{Proof Formats}
\subsection{Proof Production}
\subsection{Proof Applications}

\section{The veriT SMT Solver}
\Note{Pascal}
\subsection{Proof Formats}

The proof trace language of veriT is inspired from the SMT-LIB 2.0 language, but this similarity could be further improved.  It is particularly awkward for labeling repeating formulas, where the present solution is rather inspired from early CVC custom input language.  The language is quite coarse grained and rather falls into the ``proof trace'' category rather than full detailed proof.  Nonetheless, there has been some success to replay these traces and transform them into proof objects without heavy machinery.


\subsection{Proof Production}
\subsection{Proof Applications}

PF this needs improvement

Users targeted by our format are people who would like to replay those proofs into proof assistants, people working on interpolation (veriT does not provide a service for interpolation), and people wanting unsat cores (proofs are here overkill, but proofs are a way to get unsat cores without getting into the solver and design special techniques).

Georg Hofferek has used our proofs for multiple interpolant computation in some synthesis problems (TODO more details/citation later).  In the Rodin plugin to SMT, veriT's proofs are used as a mean to quickly extract a core.  Proofs from veriT are used in Coq-SMT (TODO should check) for proof reconstruction of SMT proofs.

\section{The Z3 SMT Solver}
\Note{Leonardo}
\subsection{Proof Formats}
\subsection{Proof Production}
\subsection{Proof Applications}

\section{The Lean Prover}
\Note{Leonardo}
\subsection{Proof Formats}
\subsection{Proof Production}
\subsection{Proof Applications}

%\section{Proof Formats}

% Briefly describe the actual text formats used to output proofs. 

% Are there standard formats in your community? If not, why not? 

% If possible and if not too large, please copy-paste the 
% grammar of the proof format(s) here.

% Please copy-paste a small but interesting example proof here. 
% Try to select an example that shows (most of) the peculiarities 
% of your proof format. 
% Use a verbatim environment (like the listings package, for example).

% What are the guiding principles involved in the design of the format? 
% Is it intended to be human-readable? easy to parse? 
% easy/efficient to verify? as small as possible? 
% In case of automated proofs, is it intended to recover
% intuition of the proofs?

% If a proof expressed in your proof format is intended 
% to be checked by another tool, what is the distribution 
% between the information that is stored in the
% proof and the information that has to be reconstructed by 
% the tool verifying the proof.

% Is there any relation between the proof format and 
% the format used for input problems?

% How fine- or coarse-grained are the proofs in this format? 
% Are you and your community satisfied with this level of detail? 
% Are there applications that might benefit from 
% a greater level of detail? 

% If you provide several proof formats, 
% explain the kinds of users that are targeted by these formats.

% Are there generic parsers available for this format? 
% In which programming languages?

% What are the trends?


%\section{Proof Production}

% What is the ``price'' (e.g. in terms of efficiency or memory overhead)
% paid to generate proofs? How much slower does the tool become? 
% How much more memory does it consume?

% In case of automated proofs, how different is the proof-producing 
% proof search algorithm from the proof search algorithm that simply
% answers "yes" or "no"?

% Is it usually possible to switch proof production 
% on and off in your kind of tool?

% How is the code for proof production? 
% Does it require substantial intervention in the usual architecture 
% and data structures of a non-proof-producing tool of the same kind?
% Could you show some code snippets here, in order to 
% illustrate proof production? 
% If there is a significant gap between the proof system and 
% the actual data structures used by the tool, 
% could you illustrate (perhaps with a simple example) 
% how a proof can be obtained from these data structures?

% Does your kind of tool keep the (partial) proof in memory during 
% the search and writes it to a file only when the search finishes? 
% Or does it write partial results (lemmas) eagerly to file? 
% In this latter case, are there techniques to cope with 
% excessive generation and writing of lemmas that may not be 
% relevant to prove the theorem?

% What are the trends?


%\section{Proof Applications}

% Which application domains have used your kind of tool? 
% Have there been any ground-breaking achievements? 
% Among these application domains, 
% which are particularly interested in the generated proofs? 
% How do they use the proofs? Do they use proofs just for 
% certifying the correctness of the provided answer? 
% Or do they extract other kinds of information 
% (e.g. unsat cores, interpolants, witnesses, programs, ...) from proofs?

% In the context of these applications, when should 
% a proof P of a certain theorem be considered better than 
% a proof Q of the same theorem? 
% For example, in case of double negation transformations, 
% why is it better to get intuitionistic proofs from classical proofs?

% What are the trends?


\section{Conclusions}

% Summarize the most important points of the previous sections.


% Thank you very much for your contribution!


\bibliographystyle{plain}
\bibliography{SMTProofs}

\end{document}
