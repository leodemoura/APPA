\documentclass{llncs}

\usepackage{url,amsmath,amssymb,a4wide}


% Dissemination Plans and Important Dates:

% - Your tutorial shall be acompanied by a paper, 
% which will be published as a chapter of a book 
% in the "Logic and Foundations of Mathematics" series 
% by College Publications. 

% - Please send us a good, though not necessarily final, 
% version of your paper ** BEFORE 1st OF JUNE **. 
% This will give us (and College Publications) sufficient time 
% to produce printed copies of a preliminary version of the book, 
% to be distributed to registered participants.

% - Afterwards there will be plenty of time to improve
% the paper/chapter and incorporate feedback gained during the event. 


% General remarks:

% - The target audience (for both the tutorials and 
% the accompanying papers) consists of Ph.D. students, 
% young post-docs and researchers from other logic-related communities.

% - Avoid obscurity and clarify concepts that might be 
% unknown to people from other communities.

% - Strive for a self-contained paper, but be concise and 
% cite papers where readers may find more information.

% - Do not hesitate to build bridges between your domain and 
% other proof-related communities if you have some ideas to do so. 
% These bridges should lead to interesting discussions during the workshop.

% - You are encouraged to compare what is done in your community 
% with what is done in other communities. 
% Try to understand and explain why your community does things differently.
% This could lead to interesting discussions too.

% - This template aims at ensuring a 
% reasonably uniform style for all speakers. 
% Nevertheless, feel free to deviate from the template if you need. 
% We are aware that not all questions are applicable to all speakers.


% We hope the questions here will guide you 
% in the production of your tutorial.

% If anything is unclear, if you have any questions, contact us!

% Thank you!


\title{ ToDo } 
% Please select a general title that reflects 
% the community you are going to represent in the event.

\author{
  ToDo Todo \inst{1} 
  \and 
  ToDo Tada \inst{2}
}

\authorrunning{T.\~Todo \and T.\~Tada}

\institute{
  ToDo\\
  \email{ }
  \and 
  ToDo \\
  \email{ }
}

\begin{document}

\maketitle

\section{Introduction}

% Briefly introduce your kind of proof production tool 
% (e.g. Sat-solvers, SMT-solvers, First-order ATPs, 
% Higher-order ATPs, Proof Assistants, ...).

% Try to give an overview encompasing all your community. 
% If possible, do not to restrict yourself only to the tool(s) you develop.

% What are the tools that pioneered proof production in your area? 
% What are the tools that currently produce proofs? 
% How widespread is the feature of proof production 
% among tools in your area? 
% How was the historical evolution of the 
% proof production feature in your area? 
% If the tools in your area cannot produce proofs easily, explain why, 
% and describe the current trends to alleviate this problem.

% Is there an open-source and minimalistic 
% *proof-producing* version of your kind of tool that would be
% particularly suitable for beginners to look at and modify?

\section{Proof Systems}

% Please list the (most common) proof systems 
% (e.g. resolution, superposition, tableaux, 
% sequent calculus, natural deduction, ...) 
% underlying state-of-the-art tools of your kind.

% Please show the inference rules of 
% (some of) these proof systems explicitly. 
% Use, for example, proof.sty or bussproofs.sty.

% Why are these proof systems particularly useful for 
% your automated deduction tools? 
% Which features make them suitable? 
% What is not so convenient in them?

% What are the trends w.r.t. proof systems for your kind of tool?

\section{Proof Search}

% Which algorithms are used to search for a proof/refutation? 
% Is the procedure able to find (counter-)models as well?

% Which criteria (e.g. speed, sizes (or other measures) of proofs/models)
% are used to evaluate whether a procedure is better than another?

% What are the "bottlenecks" that prevent current procedures 
% from solving more problems?

% Is there any mismatch between the abstract proof systems and 
% the implemented proof search procedures? 
% If so, how big is the gap between proof theory 
% and automated deduction in your field? 
% Would it be possible/desirable to develop proof systems 
% that are closer to the actual implementations?

% Are there any particular decision procedures or 
% proof search procedures that are not well-covered by proof theory yet?

% Do the proof search procedures guarantee that an optimal proof 
% (for some sense of "optimal") will be found, if a proof exists?

% Are there proof search optimization techniques 
% (e.g. resolution refinements, subsumption, 
% in-processing) that succesfully improve theorem proving efficiency, 
% but may be harmful for the generation of "good" (e.g. short, detailed, easy to check, ...) proofs? 
% Which techniques are harmful? Which are harmless?

% If the generated proofs are not optimal, 
% what kinds of redundancies may they contain? 
% Are there methods to improve the proofs in a post-processing phase? 
% Would it be possible/profitable to modify the existing 
% proof search procedures so that they generate better proofs, 
% that do not need to be post-processed afterwards?

% If the generated proofs are optimal but depend on the 
% kind of proof-checker that is used to verify the produced proofs, 
% explicit the dependency you rely on to generate optimal proofs.

% What are the trends w.r.t. proof search methods for your kind of tool?

\section{Proof Formats}

% Briefly describe the actual text formats used to output proofs. 

% Are there standard formats in your community? If not, why not? 

% If possible and if not too large, please copy-paste the 
% grammar of the proof format(s) here.

% Please copy-paste a small but interesting example proof here. 
% Try to select an example that shows (most of) the peculiarities 
% of your proof format. 
% Use a verbatim environment (like the listings package, for example).

% What are the guiding principles involved in the design of the format? 
% Is it intended to be human-readable? easy to parse? 
% easy/efficient to verify? as small as possible? 
% In case of automated proofs, is it intended to recover
% intuition of the proofs?

% If a proof expressed in your proof format is intended 
% to be checked by another tool, what is the distribution 
% between the information that is stored in the
% proof and the information that has to be reconstructed by 
% the tool verifying the proof.

% Is there any relation between the proof format and 
% the format used for input problems?

% How fine- or coarse-grained are the proofs in this format? 
% Are you and your community satisfied with this level of detail? 
% Are there applications that might benefit from 
% a greater level of detail? 

% If you provide several proof formats, 
% explain the kinds of users that are targeted by these formats.

% Are there generic parsers available for this format? 
% In which programming languages?

% What are the trends?


\section{Proof Production}

% What is the ``price'' (e.g. in terms of efficiency or memory overhead)
% paid to generate proofs? How much slower does the tool become? 
% How much more memory does it consume?

% In case of automated proofs, how different is the proof-producing 
% proof search algorithm from the proof search algorithm that simply
% answers "yes" or "no"?

% Is it usually possible to switch proof production 
% on and off in your kind of tool?

% How is the code for proof production? 
% Does it require substantial intervention in the usual architecture 
% and data structures of a non-proof-producing tool of the same kind?
% Could you show some code snippets here, in order to 
% illustrate proof production? 
% If there is a significant gap between the proof system and 
% the actual data structures used by the tool, 
% could you illustrate (perhaps with a simple example) 
% how a proof can be obtained from these data structures?

% Does your kind of tool keep the (partial) proof in memory during 
% the search and writes it to a file only when the search finishes? 
% Or does it write partial results (lemmas) eagerly to file? 
% In this latter case, are there techniques to cope with 
% excessive generation and writing of lemmas that may not be 
% relevant to prove the theorem?

% What are the trends?


\section{Proof Consumption}

% Does your kind of tool consume proofs from another kind of tool? 
% (e.g. SMT-solvers using (proofs from) sat-solvers; 
% higher-order ATPs and proof assistants using (proofs from) 
% first-order ATPs; ...)

% If so, is there anything that could be improved in the proofs 
% that are generated by this other kind of tool?

% If your tool consumes proofs from other tools, 
% is it only a proof-checker or is
% it a wider tool also used to build proofs by its own? 
% If it is a wider tool, do you also provide a lighter version of 
% your tool that is dedicated to proof-checking? 
% If not, would it be desirable?

% What are the trends?


\section{Proof Applications}

% Which application domains have used your kind of tool? 
% Have there been any ground-breaking achievements? 
% Among these application domains, 
% which are particularly interested in the generated proofs? 
% How do they use the proofs? Do they use proofs just for 
% certifying the correctness of the provided answer? 
% Or do they extract other kinds of information 
% (e.g. unsat cores, interpolants, witnesses, programs, ...) from proofs?

% In the context of these applications, when should 
% a proof P of a certain theorem be considered better than 
% a proof Q of the same theorem? 
% For example, in case of double negation transformations, 
% why is it better to get intuitionistic proofs from classical proofs?

% What are the trends?

\section{Conclusions}

% Summarize the most important points of the previous sections.


% Thank you very much for your contribution!


\bibliographystyle{plain}
\bibliography{Bibliography}

\end{document}
